import {
    Component, Input, Output, EventEmitter, OnInit, OnChanges, OnDestroy, SimpleChanges, ContentChildren,
    AfterContentInit, AfterViewInit, QueryList, Inject, forwardRef, ViewChild, ViewChildren, Pipe, PipeTransform,
    Injectable, ElementRef, ChangeDetectorRef, DoCheck, KeyValueDiffers, KeyValueDiffer, KeyValueChangeRecord,
    isDevMode, TemplateRef
} from '@angular/core';
import { Validators, FormGroup, FormControl, FormArray, FormBuilder, AbstractControl } from '@angular/forms';
import { Http, Headers, RequestOptions, ResponseContentType, Response } from '@angular/http';
import { Observable } from 'rxjs/Observable';

import { CoreHelper, TsType } from '../../pars/core';
import '../../pars/core';
import {
    PagedList, DataTable, Row, Column, TableExporter, CsvTableFormatter,
    HtmlTableFormatter, TableExportService, ExportContent, ExportFormat
} from '../../pars/data';

import { LcwGridPagingComponent } from './lcw-grid.paging.component';
import { ColumnInfo, BooleanViews, DateFormat } from './lcw-grid.column-info';
import { LcwGridColumnComponent } from './lcw-grid-column.component';
import { LcwGridService } from './lcw-grid.service';
import { ILcwGridSettings, LcwGridSettings } from './lcw-grid.settings';
import { LcwCalculateSummaryArg } from "./lcw-grid-summary-context";
import { LcwGridDataRequest, ILcwGrid } from "./lcw-grid.ilcw-grid";
import { LcwGridSummaryComponent, GridSummary, SummaryOperatorsCalculator, LcwGridSummaryOperators } from './lcw-grid-summary.component';
import { LcwGridAutoGeneratedColumnComponent, AutoGeneratedColumnsParamters } from "./lcw-grid-auto-generated-column.component";

export { PagedList, DataTable, ExportFormat, ExportContent } from '../../pars/data';
export { ColumnInfo } from './lcw-grid.column-info';
export { LcwGridColumnComponent } from './lcw-grid-column.component';
export { LcwGridService } from './lcw-grid.service';
export { LcwGridDataRequest } from "./lcw-grid.ilcw-grid";
export { LcwCalculateSummaryArg, LcwGridSummaryContext } from './lcw-grid-summary-context';
export { LcwGridSummaryComponent, LcwGridSummaryOperators } from './lcw-grid-summary.component';
export { LcwGridAutoGeneratedColumnComponent } from "./lcw-grid-auto-generated-column.component";

import { WebApiEndPoints } from '../../settings/webapiendpoints';
//import { LcwGridHeaderInternalDirective } from './lcw-grid-header-internal.directive';
//import { FileSaver } from 'file-saver';


@Component({
    moduleId: module.id,
    selector: 'lcw-grid',
    templateUrl: 'lcw-grid.component.html',
    styleUrls: ['lcw-grid.component.css'],
    providers: [TableExportService]

})
export class LcwGridComponent implements ILcwGridSettings, OnInit, OnChanges, OnDestroy, DoCheck, AfterViewInit, AfterContentInit, ILcwGrid {

    @ContentChildren(LcwGridColumnComponent)
    columnsArr: QueryList<LcwGridColumnComponent>;

    @Input() selectText: string = null;
    @Input() previousText: string = null;
    @Input() nextText: string = null;
    @Input() gridTitle: string;
    @Input() data: any;
    @Input() pageSize: number = 20;
    @Input() enablePaging: boolean = false;
    @Input() pagingOnTop: boolean = false;
    @Input() enableSearchBar: boolean = false;
    @Input() enableSelectColumn: boolean = false;
    @Input() showHeader: boolean = true;
    @Input() showLineNumbers: boolean = false;
    @Input() autoGenerateColumns: boolean = false;
    @Input() isEditable: boolean = false;
    @Input() excelExport: boolean = false;
    @Input() exportAs: ExportFormat = ExportFormat.ExcelCsvSemiColumn;
    @Input() exportFileName: string = null;

    @Input() exportOnServer: boolean = false;
    @Input() exportServerUrl: string;
    @Input() csvSeparator;
    @Input() exportHiddenColumns: boolean = false;

    @Input() columnHeaderStyle: string = null;
    @Input() columnStyle: string = null;

    @Input() exportButtonStyle: string = null;
    @Input() exportButtonClass: string = null;
    @Input() booleanView: BooleanViews;

    @Input() horizontalScroll: boolean = true;
    @Input() verticalScroll: boolean = false;
    @Input() verticalScrollRowsToShow: number = 20;
    @Input() showSettings: boolean = false;
    @Input() gridService: LcwGridService;

    @Input() alignNumbers: boolean = true;
    @Input() hideZeros: boolean = false;


    @Input() onColumnInitializing: (column: LcwGridColumnComponent) => void;

    @Output() onSelect: EventEmitter<any> = new EventEmitter<any>();
    @Input() onCalculateSummary: (arg: LcwCalculateSummaryArg) => any;
    //@Output() onCalculateSummary: EventEmitter<LcwCalculateSummaryArg> = new EventEmitter<LcwCalculateSummaryArg>();

    @Input() onCellFormat: (arg: LcwGridCellFormatArg) => LcwGridCellFormatValue;
    @Output() onDataRequest: EventEmitter<LcwGridDataRequest> = new EventEmitter<LcwGridDataRequest>();


    autoGeneratedColumnsParams: AutoGeneratedColumnsParamters = null;

    settingsDialogVisible: boolean = false;
    settings: LcwGridSettings;

    //gridData: LcwGridDataInternal;
    gridData: PagedList<any>;

    columnList: ColumnInfo[] = [];
    xcolumnList: LcwGridColumnComponent[] = [];
    columnListFromMarkup: ColumnInfo[] = [];
    @ViewChild('exportArea')
    exportArea: any;

    BooleanViews = BooleanViews;
    TsType = TsType;

    frows: FormArray;
    fgridForm: FormGroup;
    fpageNumber: FormControl;
    ftotalCount: FormControl;

    @ViewChildren(LcwGridColumnComponent)
    xgridcolumns: QueryList<LcwGridColumnComponent>;

    //@ViewChildren(LcwGridSummaryComponent)
    //summaries: QueryList<LcwGridSummaryComponent>;
    summaries: GridSummary[] = [];

    private isColumnsGenerated;
    tableId: string;
    pageNumber: number;
    private pageCount: number;

    //differ: KeyValueDiffer;

    constructor(private http: Http,
        private _fb: FormBuilder,
        private _tableExportService: TableExportService,
        public changeDetectorRef: ChangeDetectorRef,
        private _elementRef: ElementRef,
        private _differs: KeyValueDiffers) {
        this.tableId = 'xgrid_' + this.generateId();
        this.pageNumber = 1;
        this.pageCount = 1;

        //this.differ = this._differs.find({}).create(null);
    }

    get columnHeaderStyleInstance(): any {
        if (this.columnHeaderStyle == null)
            return null;
        return CoreHelper.cssStyleTextToJson(this.columnHeaderStyle);
    }

    get columnStyleInstance(): any {
        if (this.columnStyle == null)
            return null;
        return CoreHelper.cssStyleTextToJson(this.columnStyle);
    }

    //get exportButtonStyleInstance(): any {
    //    if (this.exportButtonStyle == null)
    //        return null;
    //    return CoreHelper.styleTextToJson(this.exportButtonStyle);
    //}

    getData(): DataTable | PagedList<any> {
        return this.hasDataTable ? this.generateDataTableBack() : this.generateTypedValuesBack();
    }

    private logcnt: number = 0;
    private autoRefreshData: boolean = false;

    private get frowsLength() {
        return this.frows && this.frows.value ? this.frows.value.length : -1;
    }

    get hasData(): boolean {
        return ((this.gridService && this.gridService.data) || this.data);
    }

    private formerFirstRow: any;

    hasNewData = false;

    ngAfterViewInit() {
        const styl = this._elementRef.nativeElement.attributes["style"];
        if (styl != null)
            this.columnStyle = styl.value;

    }

    ngDoCheck() {
        //const initOk = (this.autoRefreshData === true || (this!.gridData!.length !== this.frowsLength) ||
        //    (this.gridService && this.gridService.data && this.gridService.data.length !== this.frowsLength));
        //if (initOk)
        //    this.initializeData(true);

        //const initOk = this.gridData && (this!.gridData!.length !== this.frowsLength || this!.gridService!.data!.length !== this.frowsLength);

        //const len: number = this!.gridData!.length;
        //const initOk = this.gridData && (len !== this.frowsLength || (len > 0 && this.formerFirstRow == this.gridData[0]));


        if (this.hasNewData)
            this.initializeData(true);

        //if (this.gridData &&
        //        (this.autoRefreshData === true || this!.gridData!.length !== this.frowsLength) ||
        //    (this.gridService && this.gridService.data &&
        //        (this.autoRefreshData === true || this!.gridService!.data!.length !== this.frowsLength)))
        //    this.initializeData(true);

        if (isDevMode()) {
            //console.log(`ngDoCheck(${this.logcnt++})`);
            //if (this.data)
            //    this.logChanges('this.data[0]', this.data[0]);
            //this.logChanges('data', this.data);
            //this.logChanges('gridData', this.gridData);
        }
    }

    //get autoRefreshData(): boolean {
    //    return this._autoRefreshData;
    //}

    //set autoRefreshData(value: boolean) {
    //    debugger;
    //    this._autoRefreshData = value;
    //}

    //setValueWithRefresh(action: () => void): void {
    //    action();
    //}

    private refresh() {
        //this.autoRefreshData = true;
        this.changeDetectorRef.detectChanges();
        //return () => { this.autoRefreshData = true; };
    }

    //private logChanges(dataName: string, value: any): void {
    //    var changes = this.differ.diff(value);

    //    if (changes) {
    //        console.log(`${dataName}: changes detected`);
    //        changes.forEachChangedItem((r: KeyValueChangeRecord) => this.logChange(r, 'CHANGED'));
    //        changes.forEachAddedItem((r: KeyValueChangeRecord) => this.logChange(r, 'ADDED'));
    //        changes.forEachRemovedItem((r: KeyValueChangeRecord) => this.logChange(r, 'REMOVED'));

    //    } else {
    //        //console.log(`${dataName}: nothing changed`);
    //    }
    //}

    //private logChange(change: KeyValueChangeRecord, message: string): void {
    //    console.log('--->', message);
    //    console.log('    key           ', JSON.stringify(change.key));
    //    console.log('    currentValue  ', JSON.stringify(change.currentValue));
    //    console.log('    previousValue ', JSON.stringify(change.previousValue));
    //}

    ngOnChanges(changes: SimpleChanges): void {
        //console.log(`ngOnChanges(${this.logcnt++})`);


        for (let propName in changes) {
            if ((propName === 'data' || propName === 'gridService') //this.gridService.data
                || (!this.initializeDataInProcess && propName === 'gridData' && this.gridData)) {
                this.initializeData(true);

                break;
            }
        }
    }

    ngAfterContentInit(): void {
        this.initializeData(false);
    }

    ngOnInit(): void {
        this.createForm(0, 0);

        const settings = LcwGridSettings.loadFromLocalStore();
        if (settings) {
            settings.setTo(this.settings);
            settings.setTo(this);
        }
        else {
            this.clearSettings();
        }

        this.gridService.init(this);
    }

    ngOnDestroy() {
        this.onSelect.unsubscribe();
        this.onDataRequest.unsubscribe();
    }

    getItems(value: string, separator: string = LcwGridSummaryComponent.separator): string[] {
        return (value == null) ? [] : value.split(separator);
    }

    calculateSummary(column: ColumnInfo, summary: GridSummary, cell: HTMLElement): any {
        let args: LcwCalculateSummaryArg = {
            column: column,
            gridService: this.gridService,
            columnData: this.getColumnValues(column)
        }

        let cellFormatArg: LcwGridCellFormatArg = { summary: summary, column: column, value: undefined, isFormatedValue: false };
        if (summary.operator != LcwGridSummaryOperators.None) {
            cellFormatArg.value = SummaryOperatorsCalculator.calculate(summary.operator, args);
        } else
            if (summary.calculate) {
                cellFormatArg.value = summary.calculate(args);
            } else
                if (args.gridService.onCalculateSummary) {
                    cellFormatArg.value = args.gridService.onCalculateSummary(args);
                }
                else {
                    //cellFormatArg.isSummary = false;
                }
        if (cell && this.alignNumbers && CoreHelper.isNumber(cellFormatArg.value))
            this.applyStyle(cell, 'text-align: right;');

        return this.getCellFormatValue(cell, cellFormatArg) || this.formatColumnValue(cellFormatArg.value, column);

    }

    private getColumnValues(column: ColumnInfo): any[] {
        let rowCnt: number = 0;
        let collArr = [];
        for (const row of this.gridData) {
            collArr.push(ColumnInfo.getColumnValue(row, column, false));
        }
        return collArr;

    }
    // colum, row
    //private dataArray: any[][] = [];

    //private getValueFromDataArrayNoCheck(rowIndex: number, columnIndex: number): any {
    //    const column = this.dataArray[columnIndex];
    //    if (column && rowIndex < column.length)
    //        return column[rowIndex];

    //    return undefined;
    //}

    //private getValueFromDataArray(rowIndex: number, columnIndex: number): any {
    //    if (columnIndex > -1 && rowIndex > -1 &&
    //        this.dataArray && this.dataArray != null && columnIndex < this.dataArray.length) {
    //        const column = this.dataArray[columnIndex];
    //        if (rowIndex < column.length)
    //            return column[rowIndex];
    //    }
    //    return undefined;
    //}


    private getColumsToMerge(summary: GridSummary, includingHiddens: boolean = false): number {
        if (this.columnList.length == 0)
            return 0;

        //if (summary.titleColumnToMerge && summary.titleColumnToMerge > 0)
        //    return summary.titleColumnToMerge;

        //summary.titleColumnToMerge = 0;
        let merge = 0;

        const sumCols = this.getItems(summary.columns);
        const sumGroups = this.getItems(summary.groups);

        const utilColumnsToAdd = ((this.showLineNumbers == true) ? 1 : 0);

        for (let column of this.columnList) {

            let colGroups = this.getItems(column.groups);
            if (
                (column.isHidden && !includingHiddens) ||
                (column.groups == ColumnInfo.autoGenerated &&
                    (sumCols.indexOf(LcwGridSummaryComponent.autoGenerated) > -1 || sumGroups.indexOf(LcwGridSummaryComponent.autoGenerated) > -1))
                || sumCols.indexOf(column.fieldName) > -1 || this.includes(sumGroups, colGroups)
            )
                return merge + utilColumnsToAdd;
            merge++;

            //    return summary.titleColumnToMerge + utilColumnsToAdd;
            //summary.titleColumnToMerge++;
        }
        return 0;
    }

    includes(array1: any[], array2: any[]): boolean {
        //return array1 && array2 && array1.some(i => array2.includes(i));
        return array1 && array2 && array1.some(i => array2.indexOf(i) > -1);
    }

    dialogSettings: LcwGridSettings = null;
    showSettingsDailog(): void {
        this.settingsDialogVisible = true;
        this.dialogSettings = this.settings;
    }

    saveSettings(): void {
        this.settingsDialogVisible = false;
        this.settings = this.dialogSettings;
        this.settings.setTo(this);
        this.settings.saveToLocalStore();
        // SAVE TO STORE
    }


    setSettings(): void {
        this.booleanView = this.settings.booleanView;
        // this.settings.excelExport = this.excelExport;
        this.settings.exportAs = this.exportAs;
        this.settings.horizontalScroll = this.horizontalScroll;
        this.settings.pageSize = this.pageSize;
        this.settings.pagingOnTop = this.pagingOnTop;
        this.settings.showLineNumbers = this.showLineNumbers;
        this.settings.verticalScroll = this.verticalScroll;
        this.settings.verticalScrollRowsToShow = this.verticalScrollRowsToShow;
    }

    clearSettings(): void {
        this.settings = new LcwGridSettings();
        this.settings.booleanView = this.booleanView;
        // this.settings.excelExport = this.excelExport;
        this.settings.exportAs = this.exportAs;
        this.settings.horizontalScroll = this.horizontalScroll;
        this.settings.pageSize = this.pageSize;
        this.settings.pagingOnTop = this.pagingOnTop;
        this.settings.showLineNumbers = this.showLineNumbers;
        this.settings.verticalScroll = this.verticalScroll;
        this.settings.verticalScrollRowsToShow = this.verticalScrollRowsToShow;
    }

    private generateDataTableBack(): DataTable {

        let dataColumns: Column[] = [];
        let dataColumn: Column;
        let dataRows: Row[] = [];
        let dataRow: Row;

        // generate columns
        for (var colInfo of this.columnList) {
            dataColumn = new Column();
            dataColumn.name = colInfo.fieldName;
            dataColumn.type = colInfo.dataTypeName;
            dataColumns.push(dataColumn);
        }

        for (let rw of this.frows.controls) {
            dataRow = new Row();
            let rwf: FormGroup = rw as FormGroup;
            for (let i in rwf.controls) {
                let ctl: FormControl = <FormControl>rwf.controls[i];
                if (ctl.dirty)
                    dataRow.isUpdated = true;
                dataRow.values.push(ctl.value);
            }
            dataRows.push(dataRow);
        }

        let dt: DataTable = new DataTable(
            dataColumns,
            dataRows,
            this.fgridForm.get('fpageNumber').value,
            this.fgridForm.get('ftotalCount').value);
        return dt;
    }

    private generateTypedValuesBack(): PagedList<any> {
        let items: any[] = [];
        let list: PagedList<any> = new PagedList<any>(items, this.fgridForm.get('fpageNumber').value, this.fgridForm.get('ftotalCount').value);
        for (let rw of this.frows.controls) {
            let fg: FormGroup = <FormGroup>rw;
            let isDirty: boolean = false;

            for (let i in fg.controls) {
                let ctl: FormControl = <FormControl>fg.controls[i];
                if (ctl.dirty) {
                    isDirty = true;
                    break;
                }
            }
            //list.pushWithState(fg.value, isDirty);
            list.push(fg.value);

        }

        return list;
    }

    private initializeDataInProcess: boolean = false;

    private buildColumnListFromMarkupDone: boolean = false;

    private buildColumnListFromMarkup(force: boolean): void {
        if ((this.buildColumnListFromMarkupDone === false || force) &&
            (this.columnListFromMarkup && this.columnListFromMarkup != null && this.columnListFromMarkup.length > 0)) {
            for (var cm of this.columnListFromMarkup) {
                let cfound: ColumnInfo = this.columnList.find(c => c.fieldName === cm.fieldName);
                if (!cfound || cfound === null) {
                    this.columnList.push(cm);
                } else {
                    this.columnList[this.columnList.indexOf(cfound)] = cm;
                }
            }
            this.setDefaultStylesToColumns(this.columnList);

            this.buildColumnListFromMarkupDone = true;
        }
    }
    private setDefaultStylesToColumns(columns: ColumnInfo[]): void {
        for (let column of columns)
            this.setDefaultStylesToColumn(column);
    }

    private setDefaultStylesToColumn(column: ColumnInfo): void {
        column.defaultHeaderStyleText = this.columnHeaderStyle;
        column.defaultValueStyleText = this.columnStyle;
    }

    //#region Form Generation     

    private createForm(pageNumber: number, totalPages: number): void {
        //TODO: clear 
        //if (this.fgridForm != null)
        //{
        //    if (this.fgridForm.)
        //}

        this.fpageNumber = new FormControl(pageNumber);
        this.ftotalCount = new FormControl(totalPages);
        this.frows = new FormArray([]);
        this.fgridForm = new FormGroup({

            fpageNumber: this.fpageNumber,
            ftotalCount: this.ftotalCount,
            frows: this.frows,
        });
    }

    private initForm(): void {
        try {
            if (this.gridData) {
                let pn = this.gridData.pageNumber | 0;
                let tc = this.gridData.totalCount | 0;

                this.createForm(pn, tc);

                this.gridData.forEach((row, rowIndex) => {
                    let formGroup: FormGroup = new FormGroup({});
                    this.frows.setControl(rowIndex, formGroup);

                    this.columnList.forEach((col, colIndex) => {
                        let fcParam: any = {};
                        fcParam['value'] = this.getColumnValue(row, col);
                        fcParam['disabled'] = false;
                        formGroup.addControl(col.fieldName, new FormControl(fcParam));
                    });
                });

                //let rowCnt: number = 0;

                //for (const row of this.gridData) {
                //    let formGroup: FormGroup = new FormGroup({});
                //    this.frows.setControl(rowCnt, formGroup);
                //    row.forEach((colVal, colCnt) => {
                //        //for (let [colCnt, colVal] of row.entries()) {
                //        let fcParam: any = {};
                //        fcParam['value'] = colVal;
                //        fcParam['disabled'] = false;
                //        formGroup.addControl(this.columnList[colCnt].fieldName, new FormControl(fcParam));

                //    });
                //    rowCnt++;
                //}


                //debugger;
                //if (this.gridData.hasValues) {
                //    for (let rowIndex = 0; rowIndex < this.gridData.length; rowIndex++) {
                //        let formGroup: FormGroup = new FormGroup({});
                //        this.frows.setControl(rowIndex, formGroup);

                //        this.columnList.forEach((col, colIndex) => {
                //            let fcParam: any = {};
                //            fcParam['value'] = this.gridData.array[colIndex][rowIndex];
                //            fcParam['disabled'] = false;
                //            formGroup.addControl(col.fieldName, new FormControl(fcParam));
                //        });
                //    }
                //}

            }
        } catch (Exc) {
            console.error(`Error occured when initializing form in xgrid.\nError message :${Exc}`);
        }
    }

    //private addRow(rowIndex: number): FormGroup {
    //    var fg = new FormGroup({});
    //    this.frows.setControl(rowIndex, fg);
    //    return fg;
    //}

    //addEventInfo(rowEventInfo: RowEventInfo, value: any): void {
    //    if (isDevMode()) {
    //        //console.log(`addEventInfo(Row:${rowEventInfo.row}, Col:${rowEventInfo.col}, Value:${value}, `);
    //    }
    //}

    //private addColumn(row: any[], formGroup: FormGroup): void {
    //    let fcParam: any = {};
    //    fcParam['value'] = this.getColumnValue(data, columnInfo);
    //    fcParam['disabled'] = false; //!this.isEditableColumn(columnInfo);
    //    let fc: LcwFormControl = new LcwFormControl(fcParam);
    //    let rei: RowEventInfo = new RowEventInfo(rowIndex, columnInfo.fieldName);
    //    fc.eventInfo = rei;

    //    fc.valueChanges.distinctUntilChanged().subscribe(val => this.addEventInfo(rei, val));
    //    formGroup.addControl(columnInfo.fieldName, fc);
    //}

    getColumnValue(data: any, columnInfo: ColumnInfo, formated: boolean = false, cell: HTMLElement = undefined): any {
        let value = ColumnInfo.getColumnValue(data, columnInfo, formated);
        const cellFormatArg: LcwGridCellFormatArg =
            {
                summary: undefined,
                column: columnInfo,
                value: value,
                isFormatedValue: formated
            };

        if (CoreHelper.isNumber(value)) {
            if (value == 0 && this.hideZeros)
                cellFormatArg.value = ' ';
            else
                if (this.alignNumbers && cell)
                    this.applyStyle(cell, 'text-align: right;');
        }

        return this.getCellFormatValue(cell, cellFormatArg) || value;
    }

    private getCellFormatValue(cell: HTMLElement, cellFormatArg: LcwGridCellFormatArg): any {
        if (this.onCellFormat && cell != undefined) {
            const cellFormatValue = this.onCellFormat(cellFormatArg);
            if (cellFormatValue) {
                if (cellFormatValue.cellStyle) {
                    this.applyStyle(cell, cellFormatValue.cellStyle);
                }

                if (cellFormatValue.value != undefined)
                    return cellFormatValue.value;
            }
        }
        return undefined;
    }

    private applyStyle(cell: HTMLElement, style: string): void {
        const currStyle = cell.getAttribute('style');
        if (currStyle) {
            style = currStyle + style;
        }
        cell.setAttribute('style', style);
    }

    private formatColumnValue(value: any, columnInfo: ColumnInfo): any {
        return ColumnInfo.formatValue(value, columnInfo);
    }

    //private discoverColumnTypeFromValue(value: any, columnInfo: ColumnInfo): boolean {
    //    return ColumnInfo.discoverColumnTypeFromValue(value, columnInfo);
    //}

    private discoverColumnTypeFromRow(row: any, columnInfo: ColumnInfo): boolean {
        return ColumnInfo.discoverColumnTypeFromRow(row, columnInfo);
    }

    private get hasDataTable(): boolean {
        return (this.data && this.data instanceof DataTable) || (this.gridService && this.gridService.data && this.gridService.data instanceof DataTable);
    }

    private get theData(): any {
        if (this.data)
            return this.data;
        else if (this.gridService && this.gridService.data)
            return this.gridService.data;
        return null;
    }

    private initializeData(force: boolean): void {
        this.hasNewData = false;
        this.exportObject = null;
        if (!this.hasData) {
            this.gridData = null;
            if (this.gridService && this.gridService.data)
                this.gridService.data = null;
            return;
        }
        let dtx = this.theData;

        this.initializeDataInProcess = true;
        if (this.hasDataTable) {
            let dt: DataTable = dtx as DataTable;
            this.gridData = new PagedList(dt.rows, dt.pageNumber, dt.totalCount);
            //this.gridData = new LcwGridDataInternal(this.columnList, dt.rows, dt.pageNumber, dt.totalCount);
            force = true;
        }
        else {
            this.gridData = dtx;
            //this.gridData = new LcwGridDataInternal(this.columnList, dtx, dtx.pageNumber, dtx.totalCount);
        }

        this.pageNumber = dtx.pageNumber;
        this.calcPageCount(dtx.totalCount);

        this.checkAutoGenerateColumns(force);
        this.discoverColumnTypes();
        this.initForm();
        this.initializeDataInProcess = false;
        this.autoRefreshData = false;
    }

    ngAfterViewChecked() {
        if (this.horizontalScroll === true || this.verticalScroll === true) {
            const comp: HTMLElement = this._elementRef.nativeElement as HTMLElement;
            const tbl = comp.getElementsByTagName('table');
            let table: HTMLTableElement;
            if (tbl && tbl.length == 1) {
                table = tbl[0] as HTMLTableElement;
                const div = table.parentElement as HTMLDivElement;

                if (this.horizontalScroll === true) {
                    div.style.overflowX = 'auto';
                    div.style.whiteSpace = 'nowrap';
                }

                if (this.verticalScroll === true) {
                    const tblHdr = comp.getElementsByClassName('xgrid-header')
                    let tableHeight = -1;
                    let rowHeight = -1;
                    let tableHeaderHeight = -1;

                    tableHeight = table!.offsetHeight;
                    tableHeaderHeight = table!.tHead!.offsetHeight;
                    if (tblHdr && tblHdr.length == 1)
                        tableHeaderHeight += (<HTMLElement>tblHdr[0]).offsetHeight;
                    if (table.rows)
                        rowHeight = table.rows.length > 0 ? (<HTMLTableRowElement>table!.rows[0])!.offsetHeight : -1;

                    if (tableHeaderHeight != -1 && tableHeight != -1 && rowHeight != -1) {
                        const tableH = tableHeaderHeight + (rowHeight * (this.verticalScrollRowsToShow - 1));

                        table.parentElement.style.height = String(tableH) + 'px';
                        table.parentElement.style.overflowY = 'auto';
                    }
                }
            }
        }
    }

    private checkAutoGenerateColumns(force: boolean = false): void {
        this.buildColumnListFromMarkup(force);
        if (this.autoGenerateColumns === true || this.hasDataTable) {
            if (!this.isColumnsGenerated || force) {
                let generatedColumns: ColumnInfo[] = null;
                if (this.data) {
                    generatedColumns = this.generateColumnsFromData(this.columnList, this.data);
                } else if (this.gridService.data) {
                    generatedColumns = this.generateColumnsFromData(this.columnList, this.gridService.data);
                }

                if (this.columnList.length > 0 && generatedColumns != null) {
                    for (var col of this.columnList) {
                        let genCol: ColumnInfo = null;
                        if (col.fieldName != null) {
                            genCol = generatedColumns.find(f => f.fieldName === col.fieldName);
                        } else if (col.columnOrder > 0) {
                            genCol = generatedColumns.find(f => f.columnOrder === col.columnOrder);
                        }
                        if (genCol == null) {
                            if (!this.hasDataTable)
                                console.error('Error autogenerating columns\nColumn not found' + col.toString());
                            continue;
                        }
                        if (col.headerName)
                            genCol.headerName = col.headerName;

                        if (col.isHidden)
                            genCol.isHidden = col.isHidden;

                        if (col.isEditable)
                            genCol.isEditable = col.isEditable;

                        if (col.conversions)
                            genCol.conversions = col.conversions;

                        if (col.format)
                            genCol.format = col.format;
                    }
                }
                if (generatedColumns != null) {
                    this.isColumnsGenerated = true;
                    this.columnList = generatedColumns;
                }
            }
        }
    }

    private discoverColumnTypes(): void {
        let colsNotDiscovered: ColumnInfo[] = [];
        let colsToRun = this.columnList;
        //const hasDt = this.hasDataTable;
        if (this!.gridData!.length > 0) {
            for (let row of this.gridData) {
                for (let col of colsToRun) {
                    if (!this.discoverColumnTypeFromRow(row, col))
                        colsNotDiscovered.push(col);
                }
                if (colsNotDiscovered.length == 0)
                    break;
                colsToRun = colsNotDiscovered;
                colsNotDiscovered = [];
            }
        }

        //if (this!.gridData.hasValues) {
        //    this.columnList.forEach((col, colIndex) => {
        //        for (let rowIndex = 0; rowIndex < this.gridData.length; rowIndex++)
        //            if (this.discoverColumnTypeFromValue(this.gridData.array[colIndex][rowIndex], col))
        //                break;
        //    });
        //}
    }

    private cliTypeToTypeScriptType(typeName: string): TsType {
        for (let type of this.typesMap)
            if (type[1] == typeName)
                return <TsType>type[2];
        throw Error(`Unknow cli type ${typeName}`);
    }

    private typesMap: any[][] = [
        ['char', 'System.Char', TsType.string],
        ['string', 'System.String', TsType.string],
        ['bool', 'System.Boolean', TsType.boolean],
        ['byte', 'System.Byte', TsType.number],
        ['sbyte', 'System.SByte', TsType.number],
        ['decimal', 'System.Decimal', TsType.number],
        ['double', 'System.Double', TsType.number],
        ['float', 'System.Single', TsType.number],
        ['int', 'System.Int32', TsType.number],
        ['uint', 'System.UInt32', TsType.number],
        ['long', 'System.Int64', TsType.number],
        ['ulong', 'System.UInt64', TsType.number],
        ['short', 'System.Int16', TsType.number],
        ['ushort', 'System.UInt16', TsType.number],
        ['object', 'System.Object', TsType.any]];

    private generateColumnsFromData(declaredColumns: ColumnInfo[], data: any): ColumnInfo[] {
        debugger;
        var columns: ColumnInfo[] = [];
        if (data != null) {
            if (this.hasDataTable) {
                let datatable: DataTable = data as DataTable;
                let colsAdded: Column[] = [];
                if (datatable.rows.length > 0) {
                    let colNum: number = 0;
                    for (let column of declaredColumns) {
                        let col: Column = datatable.columns.find(c => c.name == column.fieldName);
                        if (col != null) {
                            column.columnIndex = datatable.columns.indexOf(col);
                            colsAdded.push(col);
                            column.dataTypeName = col.type;
                            // add header if not defined in declared columns
                            if (!column.headerName)
                                column.headerName = CoreHelper.camelCaseToWords(column.fieldName);
                            columns.push(column);
                            colNum++;
                        }
                    }

                    if (this.autoGenerateColumns === true) {
                        for (let column of datatable.columns) {
                            if (colsAdded.find(c => c.name == column.name) != null)
                                continue;
                            colNum++;
                            let ci: ColumnInfo = new ColumnInfo(
                                datatable.columns.indexOf(column),
                                CoreHelper.camelCaseToWords(column.name),
                                column.name,
                                null,
                                null,
                                colNum,
                                false,
                                this.isEditable,
                                this.cliTypeToTypeScriptType(column.type),
                                column.type,
                                null,
                                this.columnHeaderStyle,
                                this.columnStyle,
                                null,
                                ColumnInfo.autoGenerated,
                                null,
                            );

                            //let ciFound: ColumnInfo = this.columnList.find(c => c.fieldName == column.name);
                            //let ciFound: ColumnInfo = null;
                            //let ci: ColumnInfo = null;
                            //if (ciFound != null) {
                            //    const headerName = ciFound.headerName ? ciFound.headerName : CoreHelper.camelCaseToWords(column.name);
                            //    const fieldName = ciFound.fieldName;
                            //    const format = ciFound.format ? DateFormat[ciFound.format].toString() : null;
                            //    const conversions = ciFound.conversions;
                            //    const columnOrder = ciFound.columnOrder ? ciFound.columnOrder : colNum; //?????
                            //    const isHidden = ciFound.isHidden ? ciFound.isHidden : false;
                            //    const isEditable = ciFound.isEditable ? ciFound.isEditable : this.isEditable;
                            //    const dataType = ciFound.dataType ? ciFound.dataType : column.type;
                            //    const htmlContent = ciFound.htmlContent ? ciFound.htmlContent : null;
                            //    const headerStyleText = ciFound.headerStyleText ? ciFound.headerStyleText : this.columnHeaderStyle;
                            //    const valueStyleText = ciFound.valueStyleText ? ciFound.valueStyleText : this.columnStyle;
                            //    const booleanViewAs = ciFound.booleanViewAs ? ciFound.booleanViewAs : null;

                            //    ci = new ColumnInfo(headerName, fieldName, format, conversions, columnOrder, isHidden, isEditable, dataType, htmlContent, headerStyleText, valueStyleText, booleanViewAs);
                            //}
                            //else {
                            //    ci = new ColumnInfo(CoreHelper.camelCaseToWords(column.name), column.name, null, null, colNum, false, this.isEditable, column.type, null, this.columnHeaderStyle, this.columnStyle, null);
                            //}
                            this.setAutoGeneratedColumnsParams(ci);
                            columns.push(ci);
                        }
                    }
                }
            } else {
                //TODO 
                let colNum: number = declaredColumns.length;
                //for (let column of declaredColumns) {

                //    columns.push(column);
                //    colNum++;
                //}

                columns = [];
                columns.push(...declaredColumns);
                if (data.length > 0) {
                    var row = data[0];

                    for (let column in row) {

                        if (declaredColumns.find(c => c.fieldName == column) != null)
                            continue;
                        colNum++;
                        ci = new ColumnInfo(null, CoreHelper.camelCaseToWords(column), column, null, null, colNum, false, this.isEditable, /*CoreHelper.getTsType()*/ null, null, null, this.columnHeaderStyle, this.columnStyle, null, ColumnInfo.autoGenerated, null);
                        this.setAutoGeneratedColumnsParams(ci);
                        columns.push(ci);
                    }
                    let methods: string[] = this.getMethods(row);

                    if (methods && methods.length > 0) {
                        for (var method of methods) {
                            if (declaredColumns.find(c => c.fieldName == method) != null)
                                continue;

                            colNum++;
                            var ci: ColumnInfo = new ColumnInfo(null, CoreHelper.camelCaseToWords(method), method, null, null, colNum, false, false, null, ColumnInfo.typeOfMethod, null, this.columnHeaderStyle, this.columnStyle, null, ColumnInfo.autoGenerated, null);
                            this.setAutoGeneratedColumnsParams(ci);
                            columns.push(ci);
                        }
                    }
                }
            }
            this.setGridDefaultsToColumns(columns);
            return columns;
        }
    }

    setGridDefaultsToColumns(columns: ColumnInfo[]): void {
        for (let column of columns) {
            this.setGridDefaultsToColumn(column);

        }
    }

    setGridDefaultsToColumn(column: ColumnInfo): void {


        if (!(column.defaultHeaderStyleText && column.defaultHeaderStyleText != null)
            && (this.columnHeaderStyle && this.columnHeaderStyle != null)) {
            column.defaultHeaderStyleText = this.columnHeaderStyle;
        }

        if (!(column.defaultValueStyleText && column.defaultValueStyleText != null)
            && (this.columnStyle && this.columnStyle != null)) {
            column.defaultValueStyleText = this.columnStyle;
        }

        if (!(column.isEditable && column.isEditable != null)
            && (this.isEditable && this.isEditable != null)) {
            column.isEditable = this.isEditable;
        }
    }

    setAutoGeneratedColumnsParams(column: ColumnInfo): void {
        this.setDefaultStylesToColumn(column);

        if (this.autoGeneratedColumnsParams) {
            if (this.autoGeneratedColumnsParams.booleanView)
                column.booleanView = this.autoGeneratedColumnsParams.booleanView;

            if (this.autoGeneratedColumnsParams.conversions)
                column.conversions = this.autoGeneratedColumnsParams.conversions;

            if (this.autoGeneratedColumnsParams.format)
                column.format = ColumnInfo.toDateFormat(this.autoGeneratedColumnsParams.format);

            if (this.autoGeneratedColumnsParams.isEditable)
                column.isEditable = this.autoGeneratedColumnsParams.isEditable;

            if (this.autoGeneratedColumnsParams.isHidden)
                column.isHidden = this.autoGeneratedColumnsParams.isHidden;

            if (this.autoGeneratedColumnsParams.valueStyle)
                column.valueStyleText = this.autoGeneratedColumnsParams.valueStyle;

            if (this.autoGeneratedColumnsParams.headerStyle) {
                if (column.headerStyleText)
                    column.headerStyleText += this.autoGeneratedColumnsParams.headerStyle;
                else
                    column.headerStyleText = this.autoGeneratedColumnsParams.headerStyle;
            }
        }
    }

    private addSearchParameter(value: string): void {
        this.pageNumber = 1;
        this.onDataRequest.emit({ searchText: value, pageNumber: 1, pageSize: this.pageCount });
    }

    private getDatas(pageNumber?: number): void {
        const pgNum = pageNumber ? pageNumber : this.pageNumber;
        this.onDataRequest.emit({ pageNumber: pgNum, pageSize: this.pageSize });
    }

    private calcPageCount(itemsSize: number): void {
        this.pageCount = Math.floor(itemsSize / this.pageSize) + 1;
    }

    //#endregion

    //#region Utility methods

    private generateId(): string {
        var text = '';
        var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (var i = 0; i < 5; i++)
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        return text;
    }

    private getMethods(obj: any): string[] {
        var ret: string[] = [];
        for (var prop in obj) {
            //  typeof is inconsitent, duck type for accuracy
            //  This could also be written to follow the internal IsCallable algorithm
            //  http://es5.github.com/#x9.11
            if (obj[prop] && obj[prop].constructor &&
                obj[prop].call && obj[prop].apply) {
                ret.push(prop);
            }
        }
        return ret;
    }

    private getAllFunctions(value: any): any[] {
        var x = Object.getOwnPropertyNames(value.constructor);
        var myfunctions = [];
        for (var l in value) {
            var hop = value.hasOwnProperty(l);
            var isFunc = value[l] instanceof Function;
            var val = value[l];
            if (value.hasOwnProperty(l) &&
                val instanceof Function) {
                myfunctions.push(val);
            }
        }
        return myfunctions;
    }
    //#endregion


    //#region Event methods

    get showSelectColumn(): boolean {
        return (this.data != null || this.gridService.data != null) && this.columnList != null && this.columnList.length > 0 && this.enableSelectColumn == true;
    }

    private previousPage(): void {
        if (this.pageNumber === 1) {
            return;
        }
        this.pageNumber--;
        this.getDatas();
    }

    private nextPage(): void {
        if (this.pageNumber === this.pageCount) {
            return;
        }
        this.pageNumber++;
        this.getDatas();
    }

    private select(selectedData: any): void {
        let row = this.frows.value[selectedData];
        if (this.onSelect)
            this.onSelect.emit(
                {
                    result: row,
                    grid: this
                }
            );
    }

    private pageNumberChange(page: number): void {
        this.getDatas(page);
    }

    private generateExportObject(): string[][] {

        //if (this.exportObject == null) {
        //    let tableArr: string[][] = [];
        //    let lineArr: string[] = [];
        //    let col: number = 0;
        //    let line: number = 0;
        //    if (this.showLineNumbers == true) {
        //        lineArr[col++] = '#';
        //    }
        //    for (let columnInfo of this.columnList) {
        //        if (columnInfo.isHidden !== true || this.exportHiddenColumns === true)
        //            lineArr[col++] = columnInfo.headerName;
        //    }
        //    tableArr[line++] = lineArr;
        //    for (let item of this.gridData) {
        //        col = 0;
        //        lineArr = [];
        //        if (this.showLineNumbers == true)
        //            lineArr[col++] = String(((this.pageNumber - 1) * this.pageSize) + line);
        //        for (let columnInfo of this.columnList) {
        //            if (columnInfo.isHidden !== true || this.exportHiddenColumns === true) {
        //                let vl = this.getColumnValue(item, columnInfo, true);
        //                lineArr[col++] = vl ? String(vl) : '';
        //            }
        //        }
        //        tableArr[line++] = lineArr;
        //    }
        //    this.exportObject = tableArr;
        //}
        //return this.exportObject;

        if (this.exportObject == null) {
            let tableArr: string[][] = [];
            let lineArr: string[] = [];
            let col: number = 0;
            let line: number = 0;
            if (this.showLineNumbers == true) {
                lineArr[col++] = '#';
            }
            for (let columnInfo of this.columnList) {
                if (columnInfo.isHidden !== true || this.exportHiddenColumns === true)
                    lineArr[col++] = columnInfo.headerName;
            }
            tableArr[line++] = lineArr;
            for (let item of this.gridData) {
                col = 0;
                lineArr = [];
                if (this.showLineNumbers == true)
                    lineArr[col++] = String(((this.pageNumber - 1) * this.pageSize) + line);
                for (let columnInfo of this.columnList) {
                    if (columnInfo.isHidden !== true || this.exportHiddenColumns === true) {
                        let vl = this.getColumnValue(item, columnInfo, true);
                        lineArr[col++] = vl ? String(vl) : '';
                    }
                }
                tableArr[line++] = lineArr;
            }
            col = 0;

            if (this.summaries && this.summaries.length > 0) {
                let colsToMerge = 0;
                this.summaries.forEach((summary, sumIndex) => {
                    colsToMerge = this.getColumsToMerge(summary, true);
                    lineArr = [];
                    this.columnList.forEach((column, colIndex) => {
                        if (colIndex >= colsToMerge) {
                            if (column.isHidden !== true || this.exportHiddenColumns === true) {
                                lineArr[colIndex] = this.calculateSummary(column, summary, undefined);
                            }
                        }
                        else {
                            if (colIndex == 0) {
                                lineArr[colIndex] = summary.title;
                            }
                            else {
                                lineArr[colIndex] = undefined;
                            }
                        }
                    });
                    if (lineArr.length > 0)
                        tableArr[line++] = lineArr;
                });
            };
            this.exportObject = tableArr;
        }
        return this.exportObject;
    }

    private exportObject: string[][] = [];

    exportAsStyle(format: ExportFormat): string {
        return this.exportAs === format ? 'disabled btn-default' : '';
    }

    ExportFormat = ExportFormat;



    setexportTo(format: ExportFormat, result: any) {
        this.exportAs = format;
    }

    //exportLocal(format: ExportFormat): Blob {
    //    let fileExtension: string = ''
    //    let respHeader: string = '';
    //    let exp: TableExporter = null;

    //    switch (this.exportAs) {
    //        case ExportFormat.ExcelXlsx:
    //            exp = new TableExporter(new HtmlTableFormatter({ headerStyle: this.columnHeaderStyle, cellStyle: this.columnStyle }));
    //            fileExtension = 'xls';
    //            respHeader = 'data:application/vnd.ms-excel';
    //            break;
    //        case ExportFormat.ExcelCsvComma:
    //        case ExportFormat.ExcelCsvSemiColumn:
    //            const sep = this.exportAs == ExportFormat.ExcelCsvComma ? ',' : ';';
    //            exp = new TableExporter(new CsvTableFormatter({ separator: sep }));
    //            // exp = new TableExporter(new CsvTableFormatter({ separator: this.csvSeparator }));
    //            fileExtension = 'csv';
    //            respHeader = 'data:text/csv;charset=UTF-8';
    //            break;
    //        default:
    //            throw Error(`Undefined export type ${this.exportAs}`);
    //    }

    //    let content: string = '';

    //    content = exp.export(this.generateExportObject());
    //    content = '\uFEFF' + content;

    //    return new Blob([content], [respHeader]);
    //}


    private getExportContext(format: ExportFormat): ExportContent {
        let context: ExportContent = new ExportContent();

        switch (this.exportAs) {
            case ExportFormat.ExcelXlsx:
                context.exporter = new TableExporter(new HtmlTableFormatter({ headerStyle: this.columnHeaderStyle, cellStyle: this.columnStyle }));
                context.fileExtension = 'xls';
                context.header = 'data:application/vnd.ms-excel';
                break;
            case ExportFormat.ExcelCsvComma:
            case ExportFormat.ExcelCsvSemiColumn:
                const sep = this.exportAs == ExportFormat.ExcelCsvComma ? ',' : ';';
                context.exporter = new TableExporter(new CsvTableFormatter({ separator: sep }));
                // exp = new TableExporter(new CsvTableFormatter({ separator: this.csvSeparator }));
                context.fileExtension = 'csv';
                context.header = 'data:text/csv;charset=UTF-8';
                break;
            default:
                return null;
        }

        return context;
    }

    export(format: ExportFormat): any {
        return this._tableExportService.export(
            this.generateExportObject(),
            this.exportAs,
            {
                headerStyle: this.columnHeaderStyle,
                cellStyle: this.columnStyle
            });

    }

    exportInProgress: boolean = false;

    private serverVersion: string = null;

    //private async getServerVersion() {
    private getServerVersion() {
        if ((this.serverVersion != null))
            return;

        this.http.get(this.exportServerUrl + '/getversion',
            new RequestOptions({
                headers: new Headers({
                    "Content-Type": "application/json",
                    "Accept": "q=0.8;application/json;q=0.9"
                })
            }))
            .map(res => this.serverVersion = res.json())
            .subscribe();

        while (!this.serverVersion == null) {
            //await this.sleep(250);
            this.sleep(250);
        }
    }

    private asExcel(): Promise<Blob> {

        return this.http.post(WebApiEndPoints.apiServer + 'pars/asexcel',
            JSON.stringify(this.generateExportObject()),
            new RequestOptions({
                headers: new Headers({
                    "Content-Type": "application/json",
                    "Accept": "q=0.8;application/json;q=0.9"
                }),
                responseType: ResponseContentType.Blob
            }))
            .map(res => new Blob([res.blob], ['data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']))
            .toPromise();

    }

    private sleep(ms): Promise<{}> {

        return new Promise(resolve => setTimeout(resolve, ms));
    }

    exportClicked(format: ExportFormat) {
        this.exportTo(format);
    }

    exportTo(format?: ExportFormat, filename?: string): void {

        if (!(this.data || this.gridService.data))
            return;

        let content: Blob;
        let extension = null;

        if (this.exportOnServer === true) {

            if (this.exportServerUrl != null) {
                this.getServerVersion();

                //content = await this.asExcel();
                content = null;

            }
            else {
                throw new Error("exportServerUrl must be provided when exportOnServer is set to true");
            }
        } else {

            const ctx = this.getExportContext(format);
            extension = ctx.fileExtension;
            content = new Blob(['\uFEFF' + ctx.exporter.export(this.generateExportObject())], [ctx.header]);
        }


        let fileName = filename ? filename : this.exportFileName;

        if (fileName == null) {
            fileName = (this.gridTitle ? this.gridTitle : 'Report').replace(/[^a-z0-9öçşığüÖÇŞİĞÜ]/gi, '_');
        }

        if (extension == null)
            extension = 'xlsx';
        fileName += '.' + extension;

        if (navigator.msSaveBlob) {
            navigator.msSaveBlob(content, fileName);
        }
        else {
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(content);
                link.setAttribute('href', url);
                link.setAttribute('download', fileName);
                link.style.setProperty('visibility', 'hidden');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    }


    submitGrid(row: any): void {
        debugger;
        if (isDevMode()) {
            //console.log(`submitGrid(row: any) ${row}`);
            //console.log(`submitGrid(row: any) ${this.fgridForm.value}`);
        }
    }

    checkit(element: any): void {
        debugger;
    }
    //#endregion
}

//export class LcwGridDataInternal extends PagedList<any>
//{
//    get array(): any[][] {
//        return this.dataArray;
//    }
//    private dataArray: any[][];

//    constructor(public columns: ColumnInfo[], private rowArray: any[], pageNumber: number, totalCount?: number) {
//        super(rowArray, pageNumber, totalCount);
//        this.refresh();
//    }

//    //refresh(): void {
//    refresh = (): void => {
//        if (this.length == 0) {
//            this.dataArray = [];
//            return;
//        }

//        let dataArr: any[][] = [], lineArr: any[] = [], collArr: any[] = [];

//        this.columns.forEach((col, ci) => {
//            collArr = [];
//            this.forEach((item, ri) => {
//                collArr[ri] = ColumnInfo.getColumnValue(item, col, false);
//            });
//            lineArr[ci] = collArr;
//        });
//        this.dataArray = lineArr;
//    }

//    get hasValues(): boolean {
//        return this.length > 0;
//    }

//    //hasValues = (): boolean => {
//    //    return this.length > 0;
//    //}


//    getColumn(column: ColumnInfo): any[] {
//        if (column.isHidden !== true)
//            return null;
//        let lineArr = [];
//        let line = 0;
//        let colIndex = this.columns.indexOf(column);  // iki boyutlu arra        
//        for (let row of this.dataArray) {
//            lineArr[line] = row[colIndex];
//            line++;
//        }
//        return lineArr;
//    }
//}


//#region XGridDataSource 
class LcwFormControl extends FormControl {
    eventInfo: RowEventInfo;
}

class RowEventInfo {

    constructor(public row: number, public col: string) { }
}
//#endregion 

export interface LcwGridCellFormatArg {
    value: any;
    isFormatedValue: boolean;
    summary: GridSummary;
    column: ColumnInfo;
}

export interface LcwGridCellFormatValue {
    value: any;
    cellStyle?: string;
}